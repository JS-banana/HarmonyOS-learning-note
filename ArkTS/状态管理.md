# HarmonyOS 应用开发中的状态管理

## 组件状态管理

### @State

状态和UI绑定，状态更新时，UI自动更新

通过@State装饰后，框架内部会建立数据与视图间的绑定

```ts
@Component
export default struct TargetList {
  @State isComplete: boolean = false;
}
```

### @Prop

从父组件单向同步状态

- 当父组件中状态变化时，该状态值也会更新至@Prop修饰的变量
- 对@Prop修饰的变量的修改不会影响其父组件中的状态

```ts
// 父组件
@Component
export default struct TargetList {
  @State isEditMode: boolean = false;

  TargetListItem({
    isEditMode: this.isEditMode,
  })
}

// 子组件
@Component
export default struct TargetListItem {
  @Prop isEditMode: boolean;
}
```

### @Link

父子组件状态需要相互绑定进行双向同步

- 父组件中用于初始化子组件@Link变量的必须是在父组件中定义的状态变量。
- 父组件的状态属性需要加上$表示传递的是引用

```ts
// 父组件
@Component
export default struct TargetList {
  @State clickIndex: number = 0;

  TargetListItem({
    clickIndex: $clickIndex,
  })
}

// 子组件
@Component
export default struct TargetListItem {
  @Link clickIndex: number;
}
```

clickIndex状态加上@Watch("onClickIndexChanged")，表示需要监听clickIndex状态的变化；
当clickIndex状态变化时，将触发onClickIndexChanged回调

### @Watch

用@Watch修饰的状态，当状态发生变化时，会触发声明时定义的回调。

```ts
// 子组件
@Component
export default struct TargetListItem {
  @Link @Watch('onClickIndexChanged') clickIndex: number;

  onClickIndexChanged(index: number) {
    this.clickIndex = index;
  }
}
```

### @Provide和@Consume

跨组件层级双向同步状态

1. @Provide修饰的状态变量自动对提供者组件的所有后代组件可用
2. 后代组件通过使用@Consume装饰的变量来获得对提供的状态变量的访问
    - 建立在@Provide和@Consume之间的**双向数据同步**
    - 双向同步的操作与@State和@Link的组合相同
3. @Provide作为数据的提供方，可以更新其子孙节点的数据，并触发页面渲染
    - @Consume在感知到@Provide数据的更新后，会触发当前自定义组件的重新渲染
4. @Provide和@Consume可以通过相同的变量名或者相同的变量别名绑定，变量类型必须相同

```ts
// 通过相同的变量名绑定
@Provide a: number = 0;
@Consume a: number;

// 通过相同的变量别名绑定
@Provide('a') b: number = 0;
@Consume('a') c: number;
```

#### 基本原理

初始化时：

1. @Provide装饰的变量会以map的形式，传递给当前@Provide所属组件的所有子组件；
2. 子组件中如果使用@Consume变量，则会在map中查找是否有该变量名/alias（别名）对应的@Provide的变量，如果查找不到，框架会抛出JS ERROR;
3. 在初始化@Consume变量时，和@State/@Link的流程类似，@Consume变量会保存在map中查找到的@Provide变量，**并把自己注册给@Provide**——用于同步更新

当@Provide装饰的数据变化时：

1. 通过初始渲染的步骤可知，子组件@Consume已把自己注册给父组件。父组件@Provide变量变更后，会**遍历更新所有依赖它的系统组件**（elementid）和状态变量（@Consume）
2. 通知@Consume更新后，子组件所有依赖@Consume的系统组件（elementId）都会被通知更新。以此实现@Provide对@Consume状态数据同步

当@Consume装饰的数据变化时：

1. 通过初始渲染的步骤可知，子组件@Consume持有@Provide的实例，在@Consume更新后**调用@Provide的更新方法**，将更新的数值同步回@Provide，以此实现@Consume向@Provide的同步更新

### @Observed和@ObjectLink
